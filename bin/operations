#!/bin/bash
#
#
#

debug=false
verbose=false
command=""
declare -a arguments
project_home=""
configuration_file=$(dirname $0)/operations.conf

function usage() {
cat  <<EOF
Nova Ordis Release Tools

Usage:

    <command> [global-options] <command-arguments> | operations [global-options] <command> <command-arguments>

Global Options:

    -v | --verbose - verbose execution.

Commands:

    install [-f|--force]

    release <snapshot|minor|major|patch|"version-string">

        Makes a release by incrementing the release information appropriately, running all tests, building the final
        artifact and installing the artifact in the appropriate repository. If a version string is used, the string
        is checked for consistency. The release process will fail if the version string is invalid or represents an
        older version than the current version. The repository can be the local Maven repository, a directory, a
        remote server, etc.

     test - internal release tools testing shortcut. Advanced users only.

Installation:

    ./src/main/bash/operations install-release-tools <project-home-directory>

        The installation functionality can currently only be accessed from the original repository.
        'install-release-tools' installs the release tools into the 'bin' subdirectory of the specified project home
        directory. A target directory qualifies as "project home directory" if it has a Maven pom.xml in it. If an
        older version of the release tools is already installed, 'install-release-tools' will upgrade in place.

Per-Project Configuration:

    Create an operations.conf in the directory the release tools were installed into and configure local project
    properties.

    Configuration options:

    release_repository - the release repository. Can be LOCAL_MAVEN, a local directory, etc.

EOF
}

function main() {

    #
    # The script is supposed to work both if commands are specified on command line or if we use symbolic links named
    # to match the commands
    #

    identify-command-and-arguments $@

    debug "global debug: ${debug}"
    debug "global verbose: ${verbose}"
    debug "command: ${command}"

    local i=0
    while [ ${i} -lt ${#arguments[*]} ]; do
        debug "arg ${i}: ${arguments[${i}]}"
        ((i++))
    done

    [ "${command}" = "" ] && { usage; exit 0; }

    #
    # set project home
    #
    project_home=$(dirname $0)/..

    #
    # load local configuration
    #

    [ -f ${configuration_file} ] && . ${configuration_file}

    #
    # execute the top-level operation, the function expects all its arguments in the "arguments" global array
    #
    do-${command}
}

#
# Activated by --verbose|-v. Relies on a "verbose" global variable
#
function debug
{
    ${verbose} && echo "$@" 1>&2;
    return 0
}

#
# Activated by --verbose|-v. Relies on a "verbose" global variable
#
# Usage:
#        debug-arguments "$@".
#
# It is important to quote the argument, otherwise the empty arguments won't be displayed.
#
function debug-arguments
{
    local first=$1 # placeholder, to avoid IDE warnings
    local args
    if ${verbose}; then
        for arg do
            #
            # this is how we mask passwords
            #
            if [ "--aws-secret-key" = "${arg}" ]; then
                arg="--aws-secret-key ***"
            fi
            [ -z "${arg}" ] && arg="\"\""
            if [ -z "${args}" ]; then
                args="${arg}"
            else
                args="${args}, ${arg}"
            fi
        done
        echo "${FUNCNAME[1]}(${args})" 1>&2;
    fi
    return 0
}

#
# Send error information at stderr and exit. The return code is 255.
#
function fail
{
    echo "[error]: $@" 1>&2 && exit 255
}

# Send warning information at stderr and returns
#
function warn
{
    echo "[warning]: $@" 1>&2
    return 0
}

#
# Send info at stderr (not to interfere with function returns)
#
function info
{
    echo "$@" 1>&2;
    return 0
}

#
# figures out the command and the arguments. If the method completes successfully, global variable "command" contains
# the command and the global array "arguments" contains the arguments. The function also identifies global options
# such as -v|--verbose, -d|--debug and sets the global variables accordingly - it does not pass those global options
# as arguments to the command function.
#
function identify-command-and-arguments() {

    local name_under_which_we_are_invoked=$(basename $0)

    if [ "${name_under_which_we_are_invoked}" = "operations" ]; then
        debug " we are being called directly, command is among the arguments"
    else
        # we are being called via a symbolic link, the command is the name of the link
        command=${name_under_which_we_are_invoked}
    fi

    #
    # argument loop
    #
    local i=0
    while [ -n "$1" ]; do
        if [ "$1" = "--debug" -o "$1" = "-d" ]; then
            debug=true
        elif [ "$1" = "--verbose" -o "$1" = "-v" ]; then
            verbose=true
        elif [ "${1:0:1}" = "-" ]; then
             # an argument, command cannot start with -
             arguments[${i}]=$1
             ((i++))
        elif [ "${command}" = "" ]; then
             # the first non-switch argument is the command
             command=$1
        else
             arguments[${i}]=$1
             ((i++))
        fi
        shift
    done
}

#
# utilities
#

#
# return the POM project name (<name>)
#
function get-project-name() {

    local pom_file=${project_home}/pom.xml
    [ -f ${pom_file} ] || fail "pom.xml file ${pom_file} not found"

    local name
    name=$(grep -m 1 "^ *<name>" ${pom_file})
    [ -z "${name}" ] && fail "<name> not found in ${pom_file}"
    name=${name#*>}
    name=${name%%\<*}
    [ -z ${name} ] && fail "could not extract name from ${pom_file}"
    echo ${name}
}

#
# returns the project version as specified in the pom.xml file
#
function get-version() {

    local pom_file=${project_home}/pom.xml
    [ -f ${pom_file} ] || fail "pom.xml file ${pom_file} not found"
    local line;
    local artifact_base_name;

    line=$(grep -m 1 "^ *<version>" ${pom_file})
    [ -z "${line}" ] && fail "<version> not found in ${pom_file}"

    local version=${line#*>}
    version=${version%%\<*}
    [ "${version}" = "" ] && fail "could not extract version from ${pom_file}"
    echo ${version}
}

#
# replaces the version string in pom.xml with the version given as argument
#
function set-version() {

    local version=$1
    [ -z "${version}" ] && fail "'version' not specified"

    local pom_file=$2
    [ -z "${pom_file}" ] && pom_file=${project_home}/pom.xml
    [ -f ${pom_file} ] || fail "pom.xml file ${pom_file} not found"

    #
    # replace the first occurrence of <version>...</version> with our version
    #

    local tmp_file=./.tmp
    sed -e '1,/^ *<version>.*<\/version> *$/s/^\( *<version>\).*\(<\/version> *\)$/\1'${version}'\2/' ${pom_file} > ${tmp_file} || \
        fail "failed to perform sed replacement"
    diff -q ${pom_file} ${tmp_file} > /dev/null && fail "no replacement was made in ${pom_file}"
    mv ${tmp_file} ${pom_file} || fail "failed to restore ${pom_file} from ${tmp_file}"
}

# mode can be 'major', 'minor', 'patch', 'snapshot' or a full version string.
# If a full version string is provided, the function will verify that is a valid version string and the version it
# specifies if newer than the current version.
# Sends the version string at stdout.
function compute-next-version() {

    debug-arguments "$@"

    local current_version=$1
    [ -z "${current_version}" ] && fail "'current_version' not specified"
    local mode=$2
    [ -z "${mode}" ] && fail "'mode' not specified"

    local major
    local minor
    local patch
    local snapshot

    major=$(extract-version-component major ${current_version}) || exit 1
    minor=$(extract-version-component minor ${current_version}) || exit 1
    patch=$(extract-version-component patch ${current_version}) || exit 1
    snapshot=$(extract-version-component snapshot ${current_version}) || exit 1

    debug "major=${major}, minor=${minor}, patch=${patch}, snapshot=${snapshot}"

    if [ "${mode}" = "major" ]; then
        major=$(expr ${major} + 1) || exit 1
        minor=""
        patch=""
        snapshot=""
    elif [ "${mode}" = "minor" ]; then
        minor=$(expr ${minor} + 1) || exit 1
        patch=""
        snapshot=""
    elif [ "${mode}" = "patch" ]; then
        patch=$(expr ${patch} + 1) || exit 1
        snapshot=""
    elif [ "${mode}" = "snapshot" ]; then
        if [ -z "${snapshot}" ]; then
            snapshot=1
        else
            snapshot=$(expr ${snapshot} + 1) || exit 1
        fi
    else
        local new_version=${mode}
        local new_major
        local new_minor
        local new_patch
        local new_snapshot
        new_major=$(extract-version-component major ${new_version}) || exit 1
        new_minor=$(extract-version-component minor ${new_version}) || exit 1
        new_patch=$(extract-version-component patch ${new_version}) || exit 1
        new_snapshot=$(extract-version-component snapshot ${new_version}) || exit 1

        #
        # this is where new version consistency verifications are done
        #

        [ ${new_major} -lt ${major} ] && \
            fail "the major component (${new_major}) of the new version ${new_version} is older then the corresponding major component of the current version ${current_version}"

        if [ ${new_major} -eq ${major} ]; then
            #
            # we must compare minor versions
            #
            [ -z "${new_minor}" ] && new_minor_for_comparison=0 || new_minor_for_comparison=${new_minor}
            [ -z "${minor}" ] && minor_for_comparison=0 || minor_for_comparison=${minor}
            [ "${new_minor_for_comparison}" -le "${minor_for_comparison}" ] && \
                fail "the minor component (${new_minor_for_comparison}) of the new version ${new_version} is equal or older than the corresponding minor component of the current version ${current_version}"

            if [ ${new_minor_for_comparison} -eq ${minor_for_comparison} ]; then
                #
                # we must compare patch versions
                #
                [ -z "${new_patch}" ] && new_patch_for_comparison=0 || new_patch_for_comparison=${new_patch}
                [ -z "${patch}" ] && patch_for_comparison=0 || patch_for_comparison=${patch}
                [ "${new_patch_for_comparison}" -le "${patch_for_comparison}" ] && \
                    fail "the patch component (${new_patch_for_comparison}) of the new version ${new_version} is equal or older than the corresponding patch component of the current version ${current_version}"

                if [ ${new_patch_for_comparison} -eq ${patch_for_comparison} ]; then
                    #
                    # we must compare snapshot versions
                    #
                    if [ -z "${new_snapshot}" ]; then
                        debug "we end a snapshot series with the 'clean' version"
                    else
                        [ -z "${new_snapshot}" ] && new_snapshot_for_comparison=0 || new_snapshot_for_comparison=${new_snapshot}
                        [ -z "${snapshot}" ] && snapshot_for_comparison=0 || snapshot_for_comparison=${snapshot}
                        [ "${new_snapshot_for_comparison}" -le "${snapshot_for_comparison}" ] && \
                            fail "the snapshot component (${new_snapshot_for_comparison}) of the new version ${new_version} is equal or older than the corresponding snapshot component of the current version ${current_version}"
                    fi
                fi
            fi
        fi

        #
        # verification passed
        #

        major=${new_major}
        minor=${new_minor}
        patch=${new_patch}
        snapshot=${new_snapshot}
    fi

    assemble-version-string "${major}" "${minor}" "${patch}" "${snapshot}"
}

# gets the full version string and returns requested component (major, minor, patch or snapshot).
# They can only be numbers. If not numbers, the method will fail.
# If the component is absent, the method will stdout the empty string
function extract-version-component {

    local mode=$1
    [ -z "${mode}" ] && fail "'mode' not specified"
    [ ${mode} != "major" -a ${mode} != "minor" -a ${mode} != "patch" -a ${mode} != "snapshot" ] && \
        fail "unknown mode ${mode}, must be one of 'major', 'minor', 'patch' or 'snapshot'"
    local version=$2
    [ -z "${version}" ] && fail "'version' not specified"
    local original_version_string=${version}

    local snapshot
    local major
    local minor
    local patch

    local pre_snapshot=${version%-SNAPSHOT*}

    if [ "${version}" != "${pre_snapshot}" ]; then
        #
        # snapshot version
        #
        snapshot=${version#*SNAPSHOT-}
        if ! expr ${snapshot} + 1 >/dev/null 2>&1; then
            fail "the snapshot component of the version string ${original_version_string} (${snapshot}) is not an integer, version string not valid"
        fi
        version=${pre_snapshot}
    fi

    major=${version%%.*}

    if [ "${major}" != "${version}" ]; then
        # there is a dot, the major version is already extracted and stored in 'major', extract the rest
        version=${version#*.}
        minor=${version%%.*}
        if [ "${minor}" != "${version}" ]; then
            # there is a dot, the minor version is already extracted and stored in 'minor', the rest, without the dot, is the patch
            patch=${version#*.}
            [ "${patch}" = "" ] && \
                fail "no patch information follows after the last dot in ${original_version_string}, version string not valid"
            if ! expr ${patch} + 1 >/dev/null 2>&1; then
                fail "the patch component of the version string ${original_version_string} (${patch}) is not an integer, version string not valid"
            fi
        fi
        if ! expr ${minor} + 1 >/dev/null 2>&1; then
            fail "the minor component of the version string ${original_version_string} (${minor}) is not an integer, version string not valid"
        fi
    fi

    if ! expr ${major} + 1 >/dev/null 2>&1; then
        fail "the major component of the version string ${original_version_string} (${major}) is not an integer, version string not valid"
    fi

    if [ "${mode}" = "major" ]; then
        echo ${major}
    elif [ "${mode}" = "minor" ]; then
        echo ${minor}
    elif [ "${mode}" = "patch" ]; then
        echo ${patch}
    elif [ "${mode}" = "snapshot" ]; then
        echo ${snapshot}
    else
        fail "invalid mode ${mode}"
    fi
}

function assemble-version-string() {

    debug-arguments "$@"

    local major=$1
    local minor=$2
    local patch=$3
    local snapshot=$4

    [ -z "${major}" ] && fail "no major version specified"
    if ! expr ${major} + 1 >/dev/null 2>&1; then
        fail "the major component ${major} is not an integer"
    fi

    local version=${major}

    if [ -n "${minor}" ]; then
        if ! expr ${minor} + 1 >/dev/null 2>&1; then
            fail "the minor component ${minor} is not an integer"
        fi
        version=${version}.${minor}
        if [ -n "${patch}" ]; then
            if ! expr ${patch} + 1 >/dev/null 2>&1; then
                fail "the patch component ${patch} is not an integer"
            fi
            version=${version}.${patch}
        fi
    else
       [ -n "${patch}" ] && fail "no minor component provided while a patch component was provided: ${patch}"
    fi

    if [ -n "${snapshot}" ]; then
        if ! expr ${snapshot} + 1 >/dev/null 2>&1; then
            fail "the snapshot component ${snapshot} is not an integer"
        fi
        version=${version}-SNAPSHOT-${snapshot}
    fi

    echo ${version}
}

#
# returns the artifact extension as specified in the pom.xml file or fails if it cannot extract it
#
function get-artifact-extension() {

    local pom_file=${project_home}/pom.xml
    [ -f ${pom_file} ] || fail "pom.xml file ${pom_file} not found"
    local line;
    line=$(grep -m 1 "^ *<packaging>" ${pom_file})
    [ -z "${line}" ] && fail "<packaging> not found in ${pom_file}"

    local extension=${line#*>}
    extension=${extension%%\<*}
    [ "${extension}" = "" ] && fail "could not extract extension from ${pom_file}"
    echo ${extension}
}

#
# returns the artifact base name from pom.xml by reading 'finalName' (if exists) or 'artifactId' if 'finalName'
# does not exist. The base name does not contain any version or extension information.
#
function get-artifact-base-name()
{
    local pom_file=${project_home}/pom.xml
    [ -f ${pom_file} ] || fail "pom.xml file ${pom_file} not found"
    local line;
    local artifact_base_name;

    # first try 'finalName' ...
    line=$(grep -m 1 "^ *<finalName>" ${pom_file})
    if [ -z "${line}" ]; then
        # ... then try 'artifactId'.
        line=$(grep -m 1 "^ *<artifactId>" ${pom_file})
        [ -z "${line}" ] && fail "<artifactId> not found in ${pom_file}"
    fi
    artifact_base_name=${line#*>}
    artifact_base_name=${artifact_base_name%%\<*}
    [ -z "${artifact_base_name}" ] && fail "could not extract artifact base name from ${pom_file}"
    echo ${artifact_base_name}
}

#
# returns the artifact file name, as it will be generated by Maven, including base name, optionally version and
# extension. It's either 'finalName' + extension (if exists) or 'artifactId' + version + extension.
#
function get-artifact-file-name()
{
    local pom_file=${project_home}/pom.xml
    [ -f ${pom_file} ] || fail "pom.xml file ${pom_file} not found"

    local prefix
    local postfix=".$(get-artifact-extension)"

    # first try 'finalName' ...
    prefix=$(grep -m 1 "^ *<finalName>" ${pom_file})
    if [ -z "${prefix}" ]; then
        # ... then 'artifactId'
        prefix=$(grep -m 1 "^ *<artifactId>" ${pom_file})
        postfix="-$(get-version).$(get-artifact-extension)"
    fi

    [ -z "${prefix}" ] && fail "<artifactId> not found in ${pom_file}"

    prefix=${prefix#*>}
    prefix=${prefix%%\<*}
    [ -z "${prefix}" ] && fail "failed to extract artifact file prefix from ${pom_file}"
    echo ${prefix}${postfix}
}

function get-release-zip-file-name() {
    echo "$(get-artifact-base-name)-$(get-version).zip"
}

#
# return the application-specific run wrapper name. Usually is the application's "short name", which is called
# from command line. Conventionally, is the POM project name
#
function get-run-wrapper-name() {
    echo $(get-project-name)
}

#
# gets the final location (pre-zip) of the directory containing the run wrapper, identifies the run wrapper
# and configures it (main class, etc).
#
function configure-run-wrapper()
{
    debug-arguments "$@"

    local zip_bin_dir=$1

    [ -z "${zip_bin_dir}" ] && fail "'zip_bin_dir' not provided"
    [ -d ${zip_bin_dir} ] || fail "'zip_bin_dir' ${zip_bin_dir} not a directory"

    #
    # identify the run wrapper
    #

    local run_wrapper_file

    for i in $(ls ${zip_bin_dir}); do
        debug "looking at ${zip_bin_dir}/${i} ..."
        if grep -q "^main_class=\${main_class}" ${zip_bin_dir}/${i}; then
            [ -n "${run_wrapper_file}" ] && fail "two run wrapper files found: ${run_wrapper_file}, ${zip_bin_dir}/${i}"
            run_wrapper_file=${zip_bin_dir}/${i}
        fi
    done

    [ -z "${run_wrapper_file}" ] && fail "no run wrapper file found in ${zip_bin_dir}"

    debug "run wrapper file: ${run_wrapper_file}"

    local main_class
    main_class=$(find-main-class) || exit 1
    debug "main_class: ${main_class}"

    local tf=${project_home}/target/sed.tmp
    sed -e 's/^main_class=\${main_class}.*$/main_class='"${main_class}"'/' ${run_wrapper_file} > ${tf} || fail "failed to sed into ${tf}"
    if diff ${run_wrapper_file} ${tf} > /dev/null; then
        fail "${run_wrapper_file} and ${tf} are identical, no substitution has been made"
    fi

    mv ${project_home}/target/sed.tmp ${run_wrapper_file} && \
        debug "main_class set to '${main_class}' in ${run_wrapper_file}" || \
        fail "failed to mv ${project_home}/target/sed.tmp ${run_wrapper_file}"
}

#
# heuristics to find the main class of the application. Returns the main class in the format "com.example.Main"
# If the project declares a dependency on clad, it assumes the main class is provided by clad, otherwise it brute-force
# recursively searches for a "public static void main"
#
function find-main-class()
{
    local pom_file=${project_home}/pom.xml
    [ -f ${pom_file} ] || fail "pom.xml file ${pom_file} not found"

    if grep -q  "<groupId>io\.novaordis\.clad</groupId>" ${pom_file}; then
        echo "io.novaordis.clad.CommandLineApplication"
        return 0
    fi

    local src_dir=${project_home}/src/main
    local line
    line=$(grep -r "public static void main" ${src_dir}/* | head -n 1) || fail "failed to grep ${src_dir}/*"
    debug "line: ${line}"

    [ -z "${line}" ] && fail "did not find 'public static void main' in ${src_dir}/*"

    local file
    file=${line%%:*}
    debug "file: ${file}"
    [ -f ${file} ] || fail "file ${file} does not exist"

    local package
    package=$(grep "^package.*;" ${file} | sed -e 's/^package \(.*\);.*$/\1/') || fail "failed to grep/sed for package"
    debug "package: ${package}"
    [ -z "${package}" ] && fail "failed to identify the package name in ${file}"

    local class_name
    class_name=$(grep "^public class " ${file} | sed -e 's/^public class \(.*\)/\1/' | tr -d '\012' | tr -d '\015') || fail "failed to grep/sed for class name"
    class_name=${class_name%% *}
    debug "class_name: >${class_name}<"
    [ -z "${class_name}" ] && fail "failed to identify the class name in ${file}"

    echo "${package}.${class_name}"
}

function get-dependencies()
{
    local maven_quiet="-q"
    ${verbose} && maven_quiet=""
    (cd ${project_home}; mvn ${maven_quiet} dependency:build-classpath -Dmdep.pathSeparator=" " -Dmdep.outputFile=./target/dependencies.txt 1>&2) && debug "executed mvn ${maven_quiet} dependency:build-classpath -Dmdep.pathSeparator=\" \" -Dmdep.outputFile=./target/dependencies.txt" || exit 1
    cat ${project_home}/target/dependencies.txt
}

#
# We don't check whether it exists or not, we just build it. If it exists, we overwrite it.
#
# returns the newly created zip file path
#
function build-release-zip-file() {

    local artifact_path=${project_home}/target/$(get-artifact-file-name)

    [ ! -f ${artifact_path}  ] && fail "project artifact $(get-artifact-file-name) not found - build the project manually"

#    local skip_tests_arg
#    ${no_tests} && skip_tests_arg="-Dmaven.test.skip=true"
#    local maven_quiet="-q"
#    ${verbose} && maven_quiet=""
#    (cd ${project_home}; mvn ${maven_quiet} clean package ${skip_tests_arg}) && debug "mvn ${maven_quiet} clean package ${skip_tests_arg}" || exit 1

    local zip_file_base_name=$(get-artifact-base-name)-$(get-version)
    local zip_root_dir=${project_home}/target/${zip_file_base_name}

    if [ -d ${zip_root_dir} ]; then
        rm -r ${zip_root_dir} && info "deleted zip root directory ${zip_root_dir}" || fail "failed to delete zip root directory ${zip_root_dir}"
    fi

    mkdir ${zip_root_dir} && \
        debug "created zip root directory ${zip_root_dir}" || \
        fail "failed to create zip root directory ${zip_root_dir}"
    mkdir ${zip_root_dir}/lib && \
        debug "created zip root directory ${zip_root_dir}/lib" || \
        fail "failed to create zip root directory ${zip_root_dir}/lib"
    mkdir ${zip_root_dir}/bin && \
        debug "created zip root directory ${zip_root_dir}/bin" || \
        fail "failed to create zip root directory ${zip_root_dir}/bin"
    cp ${artifact_path} ${zip_root_dir}/lib && \
        debug "copied $(basename ${artifact_path}) in ${zip_root_dir}/lib" || exit 1;
    cp ${project_home}/src/main/bash/* ${zip_root_dir}/bin && \
        debug "copied scripts to ${zip_root_dir}/bin" || exit 1;
    configure-run-wrapper ${zip_root_dir}/bin && \
        debug "successfully configured the run wrapper" || exit 1;
    chmod a+rx ${zip_root_dir}/bin/* && \
        debug "chmod a+rx ${zip_root_dir}/bin/*" || exit 1;
    cp ${project_home}/README.md ${zip_root_dir} && \
        debug "copied ${project_home}/README.md ${zip_root_dir}/" || exit 1;

    local dependencies
    dependencies=$(get-dependencies) || exit 1
    debug "dependencies: ${dependencies}"
    for i in ${dependencies}; do
        [ -f ${i} ] || fail "dependency ${i} does not exist"
        cp ${i} ${zip_root_dir}/lib && \
            debug "copied dependency ${i} in ${zip_root_dir}/lib" || exit 1;
    done

    local zip_quiet="-q"
    ${verbose} && zip_quiet=""

    local zip_file_name=${zip_file_base_name}.zip
    (cd ${project_home}/target; zip ${zip_quiet} -r ${zip_file_name} ${zip_file_base_name}) 1>&2 && \
        debug "created ${project_home}/target/${zip_file_name}" || \
        exit 1

    echo ${project_home}/target/${zip_file_name}
}

#
# Expands the zip file and installs the application locally in the system directory where third-party software is
# installed (such as /opt or /usr/local). The the version is already installed, fail unless the 'force' argument is
# set to true
#
# returns the home directory of the installed application
#
function install()
{
    debug-arguments "$@"

    local zip_file=$1
    local target_dir=$2 # the system directory where third-party software is installed (/opt or /usr/local)
    local force=$3 # if not specified, defaults to "false"

    [ -z ${zip_file} ] && fail "${FUNCNAME[0]}: no zip file name provided"
    [ -z ${target_dir} ] && fail "${FUNCNAME[0]}: no target directory name provided"
    [ -d ${target_dir} ] || fail "${FUNCNAME[0]}: target directory ${target_dir} does not exist"
    [ -z ${force} ] && force=false

    local application_home_dir=${target_dir}/$(basename ${zip_file} .zip)
    debug "application_home_dir: ${application_home_dir}"

    if [ -d ${application_home_dir} ]; then

        ! ${force} && fail "${application_home_dir} already installed. Use '-f' or '--force' to overwrite"

        # --force was used, remove the existing directory for a clean installation
        rm -r ${application_home_dir} && \
            debug "removed existing ${application_home_dir}" || \
            fail "failed to remove existing ${application_home_dir}"
    fi

    local unzip_quiet="-q"
    ${verbose} && unzip_quiet=""

    unzip ${unzip_quiet} ${zip_file} -d ${target_dir} && \
        debug "unzipped ${zip_file} into ${target_dir}" || \
        fail "failed to unzip ${zip_file} into ${target_dir}"

    local link_name=$(basename ${zip_file} .zip)
    link_name=${link_name%%-[0-9]*} # be prepared to handle <name>-1.0.0, <name>-1.0.0-SNAPSHOT, etc.
    debug "link_name: ${link_name}"

    if [ -h ${target_dir}/${link_name} ]; then
        rm ${target_dir}/${link_name} && \
            debug "removed existing link ${target_dir}/${link_name}" || \
            fail "failed to remove existing link ${target_dir}/${link_name}"
    fi

    # prefer relative links, this increases the chance they'll work over NFS
    (cd ${target_dir}; ln -s ./$(basename ${application_home_dir}) ${link_name}) && \
        debug "linked ./$(basename ${application_home_dir}) to ${link_name}" || \
        fail "failed to link ./$(basename ${application_home_dir}) to ${link_name}"

    echo "${application_home_dir}"
}

#
# Installs the release into repository.
#
# Relies on the presence of 'release_repository' in scope, which should be a project local configuration. If not set,
# the function fails.
#
function install-release() {

    debug-arguments "$@"

    [ -z "${release_repository}" ] && \
        fail "'release_repository' not defined. Check your local configuration file ${configuration_file}"

    debug "release repository: ${release_repository}"

    local release_file_path=$1
    [ -z "${release_file_path}" ] && fail "'release_file' not provided"
    [ -f ${release_file_path} ] || fail "the release file ${release_file_path} does not exist"

    local target_file=${release_repository}/$(basename ${release_file_path})

    [ -f ${target_file} ] && fail "${target_file} already exists in the repository"

    cp ${release_file_path} ${target_file} && \
        info "installed $(basename ${target_file}) in ${release_repository}" || \
        fail "failed to install $(basename ${target_file}) in ${release_repository}"
}

# return 0 if the configured release_repository is LOCAL_MAVEN
function is-local-maven-release() {

    [ -z "${release_repository}" ] && \
        fail "'release_repository' not defined. Check your local configuration file ${configuration_file}"

    [ "${release_repository}" = "LOCAL_MAVEN" ] && return 0 || return 1
}

########################################################################################################################
# top level operations, exposed as external commands - they expect the arguments in the "arguments" global array
########################################################################################################################

#
# expects all its arguments in the "arguments" global array
#
function do-install-release-tools() {

    local project_home=${arguments[0]};
    [ "${project_home}" = "" ] && fail "specify the home directory of the project to install the release tools into ..."

    # sanity check - make sure the directory we're installing into is a project - it must have a pom.xml

    local pom_file=${project_home}/pom.xml

    [ -f ${pom_file} ] || fail "${project_home} does not seem to be the home of a project, there is no pom.xml file in it."

    info "installing NovaOrdis release tools into ${project_home} ..."

    local bin_dir=${project_home}/bin
    if [ ! -d ${bin_dir} ]; then
        mkdir ${bin_dir} && info "created ${bin_dir}" || fail "failed to create ${bin_dir}"
    fi

    # copy ourselves into bin - we will overwrite an existing "operations" file and that allows us to easily upgrade
    cp $0 ${bin_dir} && info "copied $0 into ${bin_dir}" || fail "failed to copy $0 into ${bin_dir}"

    # copy the sample configuration file
    if [ ! -f ${bin_dir}/operations.conf ]; then
        cp $(dirname $0)/operations.conf ${bin_dir} && \
            info "copied $(dirname $0)/operations.conf into ${bin_dir}" || \
            fail "failed to copy $(dirname $0)/operations.conf into ${bin_dir}"
    fi

    #
    # these are the links to ./operations that are going to be created in ./bin
    #
    local links="install release test";
    # create symbolic links
    (cd ${bin_dir}; \
        for link in ${links}; \
        do if [ ! -h ${link} ]; then \
                ln -s $(basename $0) ${link} && \
                    info "linked ./$(basename $0) as ./${link}" || \
                    fail "failed to link ./$(basename $0) as ./${link}"; \
           fi \
        done \
    )

    # create the run wrapper target directory and turn the run wrapper template into the final run script for the
    # application

    local run_wrapper_dir=${project_home}/src/main/bash
    if [ ! -d ${run_wrapper_dir} ]; then
        mkdir -p ${run_wrapper_dir} && \
            info "created ${run_wrapper_dir}" || \
            fail "failed to create ${run_wrapper_dir}"
    fi

    local run_wrapper_template=$(dirname $0)/run-wrapper-template
    local run_wrapper_name
    run_wrapper_name=$(get-run-wrapper-name) || exit 1
    local run_wrapper_path=${run_wrapper_dir}/${run_wrapper_name}

    if [ -f ${run_wrapper_path} ]; then
        warn "run wrapper ${run_wrapper_path} already exists, won't overwrite. Do it manually if required."
    else
        cp ${run_wrapper_template} ${run_wrapper_path} && \
            info "copied ${run_wrapper_template} as ${run_wrapper_path}" || \
            fail "failed to copy ${run_wrapper_template} as ${run_wrapper_path}"
        chmod a+x ${run_wrapper_path} && \
            debug "chmod a+x ${run_wrapper_path}" || \
            fail "failed to chmod a+x ${run_wrapper_path}"
    fi

    #
    # initialize the version mechanism
    #

    if [ ! -d ${project_home}/src/main/resources ]; then
        mkdir -p ${project_home}/src/main/resources || fail "failed to mkdir -p ${project_home}/src/main/resource"
    fi

    local release_date
    local version
    if [ ! -f ${project_home}/src/main/resources/VERSION ]; then
        (cat << EOF
version=\${version}
release_date=\${release_date}
EOF
) > ${project_home}/src/main/resources/VERSION
    fi
}

function do-test() {

    compute-next-version ${arguments[0]} ${arguments[1]}
}

#
# expects all its arguments in the "arguments" global array
#
function do-install() {

    #
    # process arguments
    #

    local force=false

    local i=0
    while [ ${i} -lt ${#arguments[*]} ]; do
        local arg=${arguments[${i}]}
        debug "do-install arg ${i}: ${arg}"
        if [ "${arg}" = "-f" -o "${arg}" = "--force" ]; then
            force=true
        fi
        ((i++))
    done

    #
    # checking pre-requisites
    #

    [ -z ${RUNTIME_DIR} ] && fail "RUNTIME_DIR environment variable not set, don't know where to install"

    debug "checking whether the project installation zip has been built ..."

    local release_zip_file_path
    release_zip_file_path=$(build-relese-zip-file) || exit 1

    local installed_path
    installed_path=$(install ${release_zip_file_path} ${RUNTIME_DIR} ${force}) || exit 1

    info "installed $(basename ${installed_path}) in $(dirname ${installed_path})"
}

#
# expects all its arguments in the "arguments" global array
#
function do-release() {

    #
    # process arguments
    #

    local mode # 'snapshot'|'minor'|'major'|'patch' or version string

    local i=0
    while [ ${i} -lt ${#arguments[*]} ]; do
        local arg=${arguments[${i}]}
        debug "do-release arg ${i}: ${arg}"
        if [ -z "${mode}" ]; then
            mode=${arg}
        fi
        ((i++))
    done

    #
    # checking pre-requisites
    #

    [ -z "${mode}" ] && fail "snapshot|minor|major|patch or the version string must be specified"

    local current_version
    current_version=$(get-version) || exit 1
    debug "current version: ${current_version}"

    local next_version
    next_version=$(compute-next-version "${current_version}" "${mode}") || exit 1
    debug "next version ${next_version}"

    set-version ${next_version}

    #
    # If we release externally (as a zip file), we only need to create the JAR locally in the project, so we package.
    # If we release to LOCAL_MAVEN, we install
    #

    if is-local-maven-release; then
        mvn clean install || fail "failed to pass tests, must restore the version in pom.xml to ${current_version} manually"
    else
        mvn clean package || fail "failed to pass tests, must restore the version in pom.xml to ${current_version} manually"
        local release_zip_file_path
        release_zip_file_path=$(build-release-zip-file) || exit 1
        install-release ${release_zip_file_path}
    fi

    info ""
    info "###########################################################################################"
    info "#"
    info "#    A new ${mode} version (${next_version}) was released locally, you may want to commit and push git #"
    info "#"
    info "###########################################################################################"
    info ""

}

main $@
